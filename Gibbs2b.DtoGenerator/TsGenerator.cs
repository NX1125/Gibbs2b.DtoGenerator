using System.Reflection;
using System.Text;
using System.Text.Json.Serialization;
using Gibbs2b.DtoGenerator.Annotation;
using Microsoft.Extensions.Logging;
using Gibbs2b.DtoGenerator.Model;

namespace Gibbs2b.DtoGenerator;

public class TsGenerator : AbstractGenerator
{
    private readonly SolutionSpec _solution;
    private readonly ILogger<TsGenerator> _logger;

    public TsGenerator(
        SolutionSpec solution,
        ILogger<TsGenerator> logger)
    {
        _solution = solution;
        _logger = logger;

        IndentStep = "  ";
    }

    private readonly List<TsImport> _filesToImport = new();

    public void Generate()
    {
        _logger.LogInformation("Generating enums");

        var enumTypeScriptProject = _solution.TypescriptProjects
            .SingleOrDefault(x => x.DefaultEnumPath != null);

        if (enumTypeScriptProject != null)
        {
            foreach (var e in _solution.Project.Enums.Values.OrderBy(p => p.Name.CapitalCase))
            {
                var enumPath = Path.Combine(enumTypeScriptProject.DefaultEnumPath!, $"{e.Name.KebabCase}.enum.gen.ts");
                e.TsEnumPath = enumPath;

                var import = new TsImport
                {
                    Name = e.Name.CapitalCase,
                    Default = true,
                    AbsoluteFrom = e.TsEnumPath[..^".ts".Length],
                    Enum = e,
                };
                _filesToImport.Add(import);

                StartFiles(enumTypeScriptProject.ProjectPaths.Select(path => Path.Combine(path, enumPath)));

                WriteLine("// <auto-generated />");

                WriteLine();
                WriteLine($"enum {e.Name} {{");

                List<int> values;
                try
                {
                    values = e.Type.GetEnumValues()
                        .Cast<int>()
                        .ToList();
                }
                catch (InvalidCastException)
                {
                    throw new InvalidOperationException(
                        $"Enum {e.Name} has values that are not integers. " +
                        $"Please use explicit values for all enum values. {e.Type.FullName}");
                }

                IDictionary<string, string> pairs = e.IsJsonName
                    ? e.Type
                        .GetEnumNames()
                        .ToDictionary(v => v, v => $"'{v}'")
                    : e.Type
                        .GetEnumNames()
                        .Zip(values)
                        .ToDictionary(v => v.First, v => v.Second.ToString());

                foreach (var value in pairs)
                {
                    WriteLine($"{value.Key} = {value.Value},");
                }

                WriteLine('}');
                WriteLine();
                WriteLine($"export default {e.Name}");
                CommitFiles();

                if (!e.TsArrayEnabled) continue;

                e.TsArrayPath = Path.Combine(enumTypeScriptProject.DefaultEnumPath!, $"{e.Name.KebabCase}-names.enum.gen.ts");

                StartFiles(enumTypeScriptProject.ProjectPaths.Select(path => Path.Combine(path, e.TsArrayPath)));

                WriteLine("// <auto-generated />");

                WriteImports(enumTypeScriptProject.DefaultEnumPath!, _filesToImport
                    .Where(x => x.Enum == e), false);

                WriteLine();
                WriteLine($"const {e.Name}Names: {e.Name}[] = [");
                IncreaseIndent();
                foreach (var pair in pairs)
                {
                    WriteLine($"{e.Name}.{pair.Key},");
                }

                DecreaseIndent();
                WriteLine(']');
                WriteLine();
                WriteLine($"export default {e.Name}Names");

                CommitFiles();
            }
        }

        _logger.LogInformation("Collecting imports");
        {
            var project = _solution.Project;
            foreach (var dto in project.TsDto.Values)
            {
                var absoluteFrom = Path.Combine(dto.TsProject!.DefaultDtoPath, $"{dto.DtoName.KebabCase}.dto.gen");

                foreach (var model in dto.Models.Values.OrderBy(x => x.Index))
                {
                    _filesToImport.Add(new TsImport
                    {
                        Name = model.DtoName,
                        AbsoluteFrom = absoluteFrom,
                        Model = model,
                    });
                }
            }
        }

        _logger.LogInformation("Generating typescript DTOs");

        {
            var project = _solution.Project;
            foreach (var dto in project.TsDto.Values)
            {
                var paths = dto.TsProject!.ProjectPaths
                    .Select(path => Path.Combine(path, dto.TsProject.DefaultDtoPath, $"{dto.DtoName.KebabCase}.dto.gen.ts"))
                    .ToArray();

                _logger.LogInformation("Generating {}", (object) paths);
                StartFiles(paths);

                WriteLine("// <auto-generated />");
                WriteLine();
                List<TsImport> imports = new();

                foreach (var model in dto.Models.Values.OrderBy(x => x.Index))
                {
                    foreach (var property in model.TsProperties)
                    {
                        if (property.Options.JsonIgnore == JsonIgnoreCondition.Always)
                            continue;

                        foreach (var type in GetTypesRecursively(property.Type))
                        {
                            switch (type)
                            {
                                case TsTypeSpec.OpaqueTypeSpec opaque:
                                    imports.Add(new TsImport
                                    {
                                        Name = opaque.BaseType.Attr.Name,
                                        AbsoluteFrom = Path.Combine(dto.TsProject.DefaultDtoPath, opaque.BaseType.Attr.ImportFrom),
                                    });
                                    break;
                                case TsTypeSpec.EnumTypeSpec enumType:
                                    imports.Add(_filesToImport.Single(x => x.Enum == enumType.Enum));
                                    break;
                                case TsTypeSpec.LazyTypeSpec lazy when lazy.Model.Model.Dto != dto:
                                    imports.Add(_filesToImport.Single(x => x.Model == lazy.Model.Model));
                                    break;
                            }
                        }
                    }
                }

                WriteImports(dto.TsProject.DefaultDtoPath, imports);

                WriteLine();

                foreach (var model in dto.Models.Values.OrderBy(x => x.Index))
                {
                    WriteLine($"export interface {model.DtoName} {{");

                    foreach (var property in model.TsProperties)
                    {
                        if (property.Options.JsonIgnore == JsonIgnoreCondition.Always)
                            continue;

                        if (property.Options.Obsolete)
                            WriteLine("/** @deprecated */");

                        StringBuilder builder = new(property.Name.CamelCase);

                        if (property.Type is TsTypeSpec.NullableTypeSpec nullable)
                        {
                            builder.Append("?: ");
                            ToTypeString(property, nullable.BaseType, builder);
                            builder.Append(" | null | undefined");
                        }
                        else if (property.Options.JsonIgnore is not JsonIgnoreCondition.Never and not null)
                        {
                            builder.Append("?: ");
                            ToTypeString(property, property.Type, builder);
                            builder.Append(" | null | undefined");
                        }
                        else if (property.Property.GetCustomAttribute<TsOptionalAttribute>() != null)
                        {
                            builder.Append("?: ");
                            ToTypeString(property, property.Type, builder);
                        }
                        else
                        {
                            builder.Append(": ");
                            ToTypeString(property, property.Type, builder);
                        }

                        WriteLine(builder.ToString());
                    }

                    WriteLine('}');
                    WriteLine();
                }

                CommitFiles();
            }
        }

        GenerateHandlers();
    }

    private IEnumerable<TsTypeSpec> GetTypesRecursively(TsTypeSpec type)
    {
        yield return type;

        foreach (var child in type.GetChildren())
        {
            foreach (var grandChild in GetTypesRecursively(child))
            {
                yield return grandChild;
            }
        }
    }

    private void ToTypeString(TsDtoPropertySpec property, TsTypeSpec type, StringBuilder builder)
    {
        switch (type)
        {
            case TsTypeSpec.OpaqueTypeSpec opaque:
                builder.Append(opaque.BaseType.Attr.Name);
                break;
            case TsTypeSpec.EnumTypeSpec enumType:
                builder.Append(enumType.Enum.Name);
                break;
            case TsTypeSpec.PrimitiveTypeSpec primitive:
                switch (primitive.Type)
                {
                    case TypeNameEnum.Int:
                    case TypeNameEnum.Long:
                    case TypeNameEnum.Float:
                    case TypeNameEnum.Double:
                    case TypeNameEnum.Decimal:
                        builder.Append("number");
                        break;
                    case TypeNameEnum.Bool:
                        builder.Append("boolean");
                        break;
                    case TypeNameEnum.String:
                    case TypeNameEnum.DateTime:
                    case TypeNameEnum.Guid:
                        builder.Append("string");
                        break;
                    case TypeNameEnum.TsVector:
                    default:
                        throw new ArgumentOutOfRangeException();
                }
                break;
            case TsTypeSpec.ArrayTypeSpec array:
                ToTypeString(property, array.BaseType, builder);
                for (var i = 0; i < array.Rank; i++)
                {
                    builder.Append("[]");
                }
                break;
            case TsTypeSpec.DictionaryTypeSpec dictionary:
                switch (dictionary.KeyType)
                {
                    case TsTypeSpec.PrimitiveTypeSpec primitive:
                        builder.Append("{ [key: ");
                        ToTypeString(property, primitive, builder);
                        builder.Append("]: ");
                        ToTypeString(property, dictionary.ValueType, builder);
                        builder.Append(" }");
                        break;
                    case TsTypeSpec.EnumTypeSpec enumType:
                        builder.Append("{ [key in ");
                        builder.Append(enumType.Enum.Name);
                        builder.Append("]: ");
                        ToTypeString(property, dictionary.ValueType, builder);
                        builder.Append(" }");
                        break;
                    default:
                        throw new NotSupportedException($"{dictionary.KeyType.GetType().FullName} at {property.Name} in {property.ParentDto.Type}");
                }
                break;
            case TsTypeSpec.EnumerableTypeSpec enumerable:
                ToTypeString(property, enumerable.BaseType, builder);
                builder.Append("[]");
                break;
            case TsTypeSpec.NullableTypeSpec nullable:
                builder.Append('(');
                ToTypeString(property, nullable.BaseType, builder);
                builder.Append(" | null | undefined)");
                break;
            case TsTypeSpec.LazyTypeSpec lazy:
                builder.Append(lazy.Model.Model.DtoName);
                break;
            case TsTypeSpec.JsTypeSpec js:
                switch (js.Type)
                {
                    case TsTypeSpec.JsType.Blob:
                        builder.Append("Blob");
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }
                break;
            default:
                throw new NotImplementedException(type.GetType().FullName);
        }
    }

    public void GenerateHandlers()
    {
        _logger.LogInformation("Generating typescript handlers ({} controllers)",
            _solution.Project.Controllers.Count);

        var project = _solution.Project;
        foreach (var ts in _solution.TypescriptProjects)
        {
            StartFiles(ts.ProjectPaths.Select(path => Path.Combine(path, ts.DefaultHandlerPath, "handlers.gen.ts")));

            // generate interface with all handlers
            WriteLine("// <auto-generated />");
            WriteLine();

            // import AxiosResponse
            WriteLine("import { AxiosResponse, AxiosRequestConfig } from 'axios'");

            // import each query and response
            foreach (var controller in project.Controllers)
            {
                if (controller.TypescriptProject != ts)
                    continue;

                foreach (var handler in controller.Handlers)
                {
                    var query = handler.Query;
                    var response = handler.Response;

                    if (query == null && response == null)
                        continue;

                    if (query?.Dto == response?.Dto)
                    {
                        WriteLine(
                            $"import {{ {query!.DtoName}, {response!.DtoName} }} from './{query.Dto.DtoName.KebabCase}.dto.gen'");
                    }
                    else
                    {
                        if (query != null)
                            WriteLine($"import {{ {query.DtoName} }} from './{query.Dto.DtoName.KebabCase}.dto.gen'");
                        if (response != null)
                            WriteLine(
                                $"import {{ {response.DtoName} }} from './{response.Dto.DtoName.KebabCase}.dto.gen'");
                    }
                }
            }

            // interface with all handlers
            WriteLine();
            WriteLine("export interface GeneratedAPI {");
            foreach (var controller in project.Controllers)
            {
                if (controller.TypescriptProject != ts)
                {
                    continue;
                }
                foreach (var handler in controller.Handlers)
                {
                    var query = handler.Query;
                    var response = handler.Response;

                    var queryName = query!.DtoName;
                    var responseName = response!.DtoName;

                    WriteLine($"{handler.Name.CamelCase}(request: {queryName}, signal?: AbortSignal, config?: AxiosRequestConfig): Promise<AxiosResponse<{responseName}>>");
                }
            }

            WriteLine("}");
            WriteLine();

            var groups = project.Controllers
                .Where(c => c.TypescriptProject == ts)
                .SelectMany(c => c.Handlers)
                .GroupBy(h => h.IsPost)
                .OrderBy(g => g.Key)
                .ToDictionary(g => g.Key,
                    g => g.ToList());

            if (!groups.ContainsKey(true))
                groups[true] = new List<HandlerSpec>();
            if (!groups.ContainsKey(false))
                groups[false] = new List<HandlerSpec>();

            // handler name to its route, grouped by method
            foreach (var group in groups)
            {
                var method = group.Key ? "POST" : "GET";
                WriteLine($"export const {method}Handlers: {{");
                WriteLine("[key in keyof GeneratedAPI]?: string");
                WriteLine("} = {");
                foreach (var handler in group.Value)
                {
                    WriteLine($"{handler.Name.CamelCase}: '{handler.Route}',");
                }

                WriteLine("}");
                WriteLine();
            }

            CommitFiles();
        }
    }

    private void WriteImports(string currentPath, IEnumerable<TsImport> imports, bool importType = true)
    {
        var groups = imports
            .GroupBy(x => x.AbsoluteFrom)
            .OrderBy(g => g.Key)
            .Select(xs => new
            {
                xs.Key,
                All = xs.ToArray(),
                Imports = xs
                    .Where(x => !x.Default)
                    .OrderBy(i => i.Name)
                    .DistinctBy(i => i.Name)
                    .ToArray(),
                Default = xs
                    .DistinctBy(x => x.Name)
                    .FirstOrDefault(x => x.Default),
                DefaultCount = xs
                    .DistinctBy(x => x.Name)
                    .Count(x => x.Default),
            })
            .ToArray();

        if (groups.Any(g => g.DefaultCount > 1))
            throw new InvalidOperationException("Multiple default imports from the same file are not allowed");

        var importTypeStr = importType ? "import type" : "import";

        foreach (var group in groups)
        {
            // get relative path
            var path = Path.GetRelativePath(currentPath, group.Key);
            if (!path.StartsWith("."))
                path = "./" + path;

            if (group.Default != null)
            {
                if (group.Imports.Any())
                {
                    WriteLine($"{importTypeStr} {group.Default.Name}, {{");
                    foreach (var i in group.Imports)
                    {
                        WriteLine(i.Name + ",");
                    }

                    WriteLine($"}} from '{path}'");
                }
                else
                {
                    WriteLine($"{importTypeStr} {group.Default.Name} from '{path}'");
                }
            }
            else
            {
                WriteLine($"{importTypeStr} {{");
                foreach (var i in group.Imports)
                {
                    WriteLine(i.Name + ",");
                }

                WriteLine($"}} from '{path}'");
            }
        }
    }

    class TsImport
    {
        public string Name { get; set; }
        public bool Default { get; set; }
        public string AbsoluteFrom { get; set; } = null!;

        public EnumSpec? Enum { get; set; }
        public TsDtoModelSpec? Model { get; set; }
    }
}