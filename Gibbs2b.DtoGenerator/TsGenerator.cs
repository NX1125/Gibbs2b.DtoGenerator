using System.Reflection;
using System.Text;
using System.Text.Json.Serialization;
using Gibbs2b.DtoGenerator.Annotation;
using Microsoft.Extensions.Logging;
using Gibbs2b.DtoGenerator.Model;

namespace Gibbs2b.DtoGenerator;

public class TsGenerator : AbstractGenerator
{
    private readonly SolutionSpec _solution;
    private readonly ILogger<TsGenerator> _logger;

    public TsGenerator(
        SolutionSpec solution,
        ILogger<TsGenerator> logger)
    {
        _solution = solution;
        _logger = logger;

        IndentStep = "  ";
    }

    public void Generate()
    {
        _logger.LogInformation("Generating enums");

        foreach (var project in _solution.TypescriptProjects)
        {
            foreach (var e in _solution.Project.Enums.Values.OrderBy(p => p.Name.CapitalCase))
            {
                StartFiles(project.Paths.Select(path => Path.Combine(path, $"{e.Name.KebabCase}.enum.gen.ts")));

                WriteLine("// <auto-generated />");

                WriteLine();
                WriteLine($"enum {e.Name} {{");

                List<int> values;
                try
                {
                    values = e.Type.GetEnumValues()
                        .Cast<int>()
                        .ToList();
                }
                catch (InvalidCastException)
                {
                    throw new InvalidOperationException(
                        $"Enum {e.Name} has values that are not integers. " +
                        $"Please use explicit values for all enum values. {e.Type.FullName}");
                }

                IDictionary<string, string> pairs = e.IsJsonName
                    ? e.Type
                        .GetEnumNames()
                        .ToDictionary(v => v, v => $"'{v}'")
                    : e.Type
                        .GetEnumNames()
                        .Zip(values)
                        .ToDictionary(v => v.First, v => v.Second.ToString());

                foreach (var value in pairs)
                {
                    WriteLine($"{value.Key} = {value.Value},");
                }

                WriteLine('}');
                WriteLine();
                WriteLine($"export default {e.Name}");
                CommitFiles();

                if (!e.TsArrayEnabled) continue;

                StartFiles(project.Paths.Select(path => Path.Combine(path, $"{e.Name.KebabCase}-names.enum.gen.ts")));

                WriteLine("// <auto-generated />");

                WriteLine($"import {e.Name} from './{e.Name.KebabCase}.enum.gen'");
                WriteLine();
                WriteLine($"const {e.Name}Names: {e.Name}[] = [");
                IncreaseIndent();
                foreach (var pair in pairs)
                {
                    WriteLine($"{e.Name}.{pair.Key},");
                }

                DecreaseIndent();
                WriteLine(']');
                WriteLine();
                WriteLine($"export default {e.Name}Names");

                CommitFiles();
                StartFiles(project.Paths.Select(path =>
                    Path.Combine(path, $"{e.Name.KebabCase}-name-set.enum.gen.ts")));

                WriteLine("// <auto-generated />");

                WriteLine($"import {e.Name} from './{e.Name.KebabCase}.enum.gen'");
                WriteLine($"import Names from './{e.Name.KebabCase}-names.enum.gen'");
                WriteLine();
                WriteLine($"const {e.Name}NameSet: Set<{e.Name}> = new Set(Names)");
                WriteLine($"export default {e.Name}NameSet");

                CommitFiles();
            }
        }

        _logger.LogInformation("Generating typescript DTOs");

        {
            var project = _solution.Project;
            foreach (var dto in project.TsDto.Values)
            {
                _logger.LogInformation("Generating {}", dto.TsPaths);
                StartFiles(dto.TsPaths);

                WriteLine("// <auto-generated />");
                WriteLine();
                List<(string Path, string Name)> imports = new();

                foreach (var model in dto.Models.Values.OrderBy(x => x.Index))
                {
                    foreach (var property in model.TsProperties)
                    {
                        if (property.Options.JsonIgnore == JsonIgnoreCondition.Always)
                            continue;

                        foreach (var type in GetTypesRecursively(property.Type))
                        {
                            switch (type)
                            {
                                case TsTypeSpec.OpaqueTypeSpec opaque:
                                    // imports[opaque.BaseType.Attr.ImportFrom].Add(opaque.BaseType.Attr.Name);
                                    imports.Add((opaque.BaseType.Attr.ImportFrom, opaque.BaseType.Attr.Name));
                                    break;
                                case TsTypeSpec.EnumTypeSpec enumType:
                                    // imports[$"./{enumType.Enum.Name.KebabCase}.enum.gen"] = new HashSet<string> { enumType.Enum.Name.ToString() };
                                    imports.Add(($"./{enumType.Enum.Name.KebabCase}.enum.gen", enumType.Enum.Name.ToString()));
                                    break;
                                case TsTypeSpec.LazyTypeSpec lazy when lazy.Model.Model.Dto != dto:
                                    // imports[$"./{lazy.Model.Model.Dto.DtoName.KebabCase}.dto.gen"].Add(lazy.Model.Model.DtoName);
                                    imports.Add(($"./{lazy.Model.Model.Dto.DtoName.KebabCase}.dto.gen", lazy.Model.Model.DtoName));
                                    break;
                            }
                        }
                    }
                }

                foreach (var group in imports
                             .GroupBy(x => x.Path)
                             .OrderBy(g => g.Key))
                {
                    if (group.Key.EndsWith(".enum.gen"))
                    {
                        WriteLine($"import type {group.First().Name} from '{group.Key}'");
                        continue;
                    }

                    WriteLine("import {");
                    foreach (var i in group
                                 .Distinct()
                                 .OrderBy(i => i.Name.ToLower()))
                    {
                        WriteLine($"{i.Name},");
                    }

                    WriteLine($"}} from '{group.Key}'");
                }

                WriteLine();

                foreach (var model in dto.Models.Values.OrderBy(x => x.Index))
                {
                    WriteLine($"export interface {model.DtoName} {{");

                    foreach (var property in model.TsProperties)
                    {
                        if (property.Options.JsonIgnore == JsonIgnoreCondition.Always)
                            continue;

                        if (property.Options.Obsolete)
                            WriteLine("/** @deprecated */");

                        StringBuilder builder = new(property.Name.CamelCase);

                        if (property.Type is TsTypeSpec.NullableTypeSpec nullable)
                        {
                            builder.Append("?: ");
                            ToTypeString(property, nullable.BaseType, builder);
                            builder.Append(" | null | undefined");
                        }
                        else if (property.Options.JsonIgnore is not JsonIgnoreCondition.Never and not null)
                        {
                            builder.Append("?: ");
                            ToTypeString(property, property.Type, builder);
                            builder.Append(" | null | undefined");
                        }
                        else if (property.Property.GetCustomAttribute<TsOptionalAttribute>() != null)
                        {
                            builder.Append("?: ");
                            ToTypeString(property, property.Type, builder);
                        }
                        else
                        {
                            builder.Append(": ");
                            ToTypeString(property, property.Type, builder);
                        }

                        WriteLine(builder.ToString());
                    }

                    WriteLine('}');
                    WriteLine();
                }

                CommitFiles();
            }
        }

        GenerateHandlers();
    }

    private IEnumerable<TsTypeSpec> GetTypesRecursively(TsTypeSpec type)
    {
        yield return type;

        foreach (var child in type.GetChildren())
        {
            foreach (var grandChild in GetTypesRecursively(child))
            {
                yield return grandChild;
            }
        }
    }

    private void ToTypeString(TsDtoPropertySpec property, TsTypeSpec type, StringBuilder builder)
    {
        switch (type)
        {
            case TsTypeSpec.OpaqueTypeSpec opaque:
                builder.Append(opaque.BaseType.Attr.Name);
                break;
            case TsTypeSpec.EnumTypeSpec enumType:
                builder.Append(enumType.Enum.Name);
                break;
            case TsTypeSpec.PrimitiveTypeSpec primitive:
                switch (primitive.Type)
                {
                    case TypeNameEnum.Int:
                    case TypeNameEnum.Long:
                    case TypeNameEnum.Float:
                    case TypeNameEnum.Double:
                    case TypeNameEnum.Decimal:
                        builder.Append("number");
                        break;
                    case TypeNameEnum.Bool:
                        builder.Append("boolean");
                        break;
                    case TypeNameEnum.String:
                    case TypeNameEnum.DateTime:
                    case TypeNameEnum.Guid:
                        builder.Append("string");
                        break;
                    case TypeNameEnum.TsVector:
                    default:
                        throw new ArgumentOutOfRangeException();
                }
                break;
            case TsTypeSpec.ArrayTypeSpec array:
                ToTypeString(property, array.BaseType, builder);
                for (var i = 0; i < array.Rank; i++)
                {
                    builder.Append("[]");
                }
                break;
            case TsTypeSpec.DictionaryTypeSpec dictionary:
                switch (dictionary.KeyType)
                {
                    case TsTypeSpec.PrimitiveTypeSpec primitive:
                        builder.Append("{ [key: ");
                        ToTypeString(property, primitive, builder);
                        builder.Append("]: ");
                        ToTypeString(property, dictionary.ValueType, builder);
                        builder.Append(" }");
                        break;
                    case TsTypeSpec.EnumTypeSpec enumType:
                        builder.Append("{ [key in ");
                        builder.Append(enumType.Enum.Name);
                        builder.Append("]: ");
                        ToTypeString(property, dictionary.ValueType, builder);
                        builder.Append(" }");
                        break;
                    default:
                        throw new NotSupportedException($"{dictionary.KeyType.GetType().FullName} at {property.Name} in {property.ParentDto.Type}");
                }
                break;
            case TsTypeSpec.EnumerableTypeSpec enumerable:
                ToTypeString(property, enumerable.BaseType, builder);
                builder.Append("[]");
                break;
            case TsTypeSpec.NullableTypeSpec nullable:
                builder.Append('(');
                ToTypeString(property, nullable.BaseType, builder);
                builder.Append(" | null | undefined)");
                break;
            case TsTypeSpec.LazyTypeSpec lazy:
                builder.Append(lazy.Model.Model.DtoName);
                break;
            case TsTypeSpec.JsTypeSpec js:
                switch (js.Type)
                {
                    case TsTypeSpec.JsType.Blob:
                        builder.Append("Blob");
                        break;
                    default:
                        throw new ArgumentOutOfRangeException();
                }
                break;
            default:
                throw new NotImplementedException(type.GetType().FullName);
        }
    }

    public void GenerateHandlers()
    {
        _logger.LogInformation("Generating typescript handlers ({} controllers)",
            _solution.Project.Controllers.Count);

        var project = _solution.Project;
        foreach (var ts in _solution.TypescriptProjects)
        {
            StartFiles(ts.Paths.Select(path => Path.Combine(path, "handlers.gen.ts")));

            // generate interface with all handlers
            WriteLine("// <auto-generated />");
            WriteLine();

            // import AxiosResponse
            WriteLine("import { AxiosResponse, AxiosRequestConfig } from 'axios'");

            // import each query and response
            foreach (var controller in project.Controllers)
            {
                if (controller.TypescriptProject != ts)
                    continue;

                foreach (var handler in controller.Handlers)
                {
                    var query = handler.Query;
                    var response = handler.Response;

                    if (query == null && response == null)
                        continue;

                    if (query?.Dto == response?.Dto)
                    {
                        WriteLine(
                            $"import {{ {query!.DtoName}, {response!.DtoName} }} from './{query.Dto.DtoName.KebabCase}.dto.gen'");
                    }
                    else
                    {
                        if (query != null)
                            WriteLine($"import {{ {query.DtoName} }} from './{query.Dto.DtoName.KebabCase}.dto.gen'");
                        if (response != null)
                            WriteLine(
                                $"import {{ {response.DtoName} }} from './{response.Dto.DtoName.KebabCase}.dto.gen'");
                    }
                }
            }

            // interface with all handlers
            WriteLine();
            WriteLine("export interface GeneratedAPI {");
            foreach (var controller in project.Controllers)
            {
                if (controller.TypescriptProject != ts)
                {
                    continue;
                }
                foreach (var handler in controller.Handlers)
                {
                    var query = handler.Query;
                    var response = handler.Response;

                    var queryName = query!.DtoName;
                    var responseName = response!.DtoName;

                    WriteLine($"{handler.Name.CamelCase}(request: {queryName}, signal?: AbortSignal, config?: AxiosRequestConfig): Promise<AxiosResponse<{responseName}>>");
                }
            }

            WriteLine("}");
            WriteLine();

            var groups = project.Controllers
                .Where(c => c.TypescriptProject == ts)
                .SelectMany(c => c.Handlers)
                .GroupBy(h => h.IsPost)
                .OrderBy(g => g.Key)
                .ToDictionary(g => g.Key,
                    g => g.ToList());

            if (!groups.ContainsKey(true))
                groups[true] = new List<HandlerSpec>();
            if (!groups.ContainsKey(false))
                groups[false] = new List<HandlerSpec>();

            // handler name to its route, grouped by method
            foreach (var group in groups)
            {
                var method = group.Key ? "POST" : "GET";
                WriteLine($"export const {method}Handlers: {{");
                WriteLine("[key in keyof GeneratedAPI]?: string");
                WriteLine("} = {");
                foreach (var handler in group.Value)
                {
                    WriteLine($"{handler.Name.CamelCase}: '{handler.Route}',");
                }

                WriteLine("}");
                WriteLine();
            }

            CommitFiles();
        }
    }
}