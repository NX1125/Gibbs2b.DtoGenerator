using System.Text.Json.Serialization;
using Gibbs2b.DtoGenerator.Model;
using Microsoft.Extensions.Logging;

namespace Gibbs2b.DtoGenerator;

public class TsGenerator : AbstractGenerator
{
    private readonly SolutionSpec _solution;
    private readonly ILogger<TsGenerator> _logger;

    public TsGenerator(
        SolutionSpec solution,
        ILogger<TsGenerator> logger)
    {
        _solution = solution;
        _logger = logger;
    }

    public void Generate()
    {
        _logger.LogInformation("Generating typescript DTOs");

        foreach (var project in _solution.Projects)
        {
            foreach (var dto in project.TsDto)
            {
                _logger.LogInformation("Generating {}", dto.TsPaths);
                StartFiles(dto.TsPaths);

                WriteLine("// <auto-generated />");
                WriteLine();
                WriteLine("import {");
                var imports = new HashSet<string>();
                foreach (var model in dto.Models)
                {
                    foreach (var property in model.Properties)
                    {
                        if (property.TypeNameType == TypeNameEnum.Enum && property.Options.JsonIgnore != JsonIgnoreCondition.Always)
                            imports.Add(property.EnumName);
                    }
                }

                foreach (var i in imports.OrderBy(i => i.ToLower()))
                {
                    WriteLine($"{i},");
                }

                WriteLine("} from './model'");
                WriteLine();

                foreach (var model in dto.Models)
                {
                    WriteLine($"export interface {model.DtoName} {{");

                    foreach (var property in model.TsProperties)
                    {
                        if (property.Options.JsonIgnore == JsonIgnoreCondition.Always)
                            continue;

                        if (property.Options.Obsolete)
                            WriteLine("/** @deprecated */");

                        var type = property.TypeNameType switch
                        {
                            TypeNameEnum.Int => "number",
                            TypeNameEnum.Long => "number",
                            TypeNameEnum.Float => "number",
                            TypeNameEnum.Double => "number",
                            TypeNameEnum.Decimal => "number",
                            TypeNameEnum.Bool => "boolean",
                            TypeNameEnum.String => "string",
                            TypeNameEnum.DateTime => "string",
                            TypeNameEnum.Guid => "string",
                            TypeNameEnum.Model => property.TsTypeModel!.DtoName,
                            TypeNameEnum.Enum => property.EnumName,
                            _ => throw new ArgumentOutOfRangeException(property.Name.CapitalCase, property.TypeNameType, null),
                        };

                        if (property.Options.IsNullableItem)
                            type = $"({type} | null | undefined)";

                        type = property.EnumerableType switch
                        {
                            EnumerableType.Enumerable => $"{type}[]",
                            EnumerableType.Collection => $"{type}[]",
                            EnumerableType.Array => $"{type}[]",
                            EnumerableType.List => $"{type}[]",
                            _ => type,
                        };

                        var optional = "";

                        if (property.Options.IsNullable ||
                            property.Options.JsonIgnore is JsonIgnoreCondition.WhenWritingDefault or JsonIgnoreCondition.WhenWritingNull)
                        {
                            type = $"{type} | null | undefined";
                            optional = "?";
                        }

                        switch (property.TypeNameType)
                        {
                            case TypeNameEnum.Bool:
                                if (model.NullableBool)
                                    optional = "?";
                                break;
                        }

                        WriteLine($"{property.Name.CamelCase}{optional}: {type}");
                    }

                    WriteLine('}');
                    WriteLine();
                }

                CommitFiles();
            }
        }
    }
}